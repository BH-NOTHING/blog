### React 组件设计原则 —— 为什么推荐使用受控组件

![](http://with.muyunyun.cn/21ec115261725fc7a37543143c1e89ed.jpg-400)

### 重新定义受控与非受控组件的边界

![](http://with.muyunyun.cn/3e1327ce86f89d2763d8fed9c169887d.jpg-400)

[React 官网中](https://reactjs.org/docs/uncontrolled-components.html)对非受控组件与受控组件作了如图中下划线的边界定义。一经推敲, 该定义是缺乏了些`完整性`和`严谨性`的, 比如针对非表单组件(弹框、轮播图)如何划分受控与非受控的边界? 又比如非受控组件是否真的如文案上所说的数据的展示与变更都由 dom 自身接管呢?

在非受控组件中, 通常业务调用方只需传入一个`初始默认值`便可使用该组件。以 Input 组件为例:

```js
// 组件提供方
function Input({ defaultValue }) {
  return <input defaultValue={defaultValue} />
}

// 调用方
function Demo() {
  return <Input defaultValue={1} />
}
```

在受控组件中, 数值的`展示与变更`则分别由组件的 `state` 与 `setState` 接管。同样以 Input 组件为例:

```js
// 组件提供方
function Input() {
  const [value, setValue] = React.useState(1)
  return <input value={value} onChange={e => setValue(e.target.value)} />
}

// 调用方
function Demo() {
  return <Input />
}
```

有意思的一个问题来了, `Input` 组件到底是受控的还是非受控的呢? 我们甚至还可以对代码稍加改动成 `<Input defaultValue={1} />` 的最初调用方式:

```js
// 组件提供方
function Input({ defaultValue }) {
  const [value, setValue] = React.useState(defaultValue)
  return <input value={value} onChange={e => setValue(e.target.value)} />
}

// 调用方
function Demo() {
  return <Input defaultValue={1} />
}
```

尽管此时 Input 组件本身是一个受控组件, 但与之相对的调用方失去了更改 Input 组件值的`控制权`, 所以对调用方而言, Input 组件是一个非受控组件。

如何做到不管是组件提供方还是调用方 Input 组件都为受控组件呢? 提供方让出控制权即可, 调整代码如下:

```js
// 组件提供方
function Input({ value, onChange }) {
  return <input value={value} onChange={onChange} />
}

// 调用方
function Demo() {
  const [value, setValue] = React.useState(1)
  return <Input value={value} onChange={e => setValue(e.target.value)} />
}
```

经过上述代码的推演后, 概括如下: 受控以及非受控组件的边界划分取决于`当前组件对于子组件的值变更是否拥有控制权`。如若有则该子组件是当前组件的受控组件; 如若没有则该子组件是当前组件的非受控组件。

### 职能范围



`非受控组件实现的功能受控组件都能实现, 受控组件实现的功能非受控组件不一定能实现`;

### 陷阱

```js
<Input defaultValue="" value="" onChange={() => {}} />
```

### link

* [Controlled Components](https://reactjs.org/docs/forms.html#controlled-components)
* [Uncontrolled Components](https://reactjs.org/docs/uncontrolled-components.html)

popOver